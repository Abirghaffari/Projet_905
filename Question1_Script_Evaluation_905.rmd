---
title: "Evaluation_905"
author: "Abir Ben Abdelghaffar/Alban LAMGHARI/Mohamed DUMONT"
date: "12/07/2024"
output: 
      html_document:
    toc: true
---

``````{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
# Installation des Bibliothèques nécessaires 
install.packages("l4m")
install.packages("car")
install.packages("ggplot")
# Chargement de dataframe 
data <- read.csv("G:/Mon Drive/Evaluation_905/dataProjet_2025.csv")
head(data)
```


```{r}

# Filtrage des lignes où 'recherche-esp_Ib_nom_plantae' est "Carpinus betulus L., 1753"

data_filtred <- data[data$recherche_esp_lb_nom_plantae == "Carpinus betulus L., 1753",]

head(data_filtred)
summary(data_filtred)

```


```{r}
# Visualisation graphique de l'ensemble des quantiles de l’échantillon 

fRep_DBH <- ecdf(data_filtred$DBH) 
plot(fRep_DBH,xlab="DBH",ylab="Quantile",main="Fonction de répartition de DBH")
```
```{r}
# Application d'un modèle ANOVA pour évaluer l'effet de rélevée sur la variable d'étude diamètre des arbres de la classe Charme
modAnova <- lm(DBH~0+releve,data=data_filtred)
```

### Adéquation des erreurs ( des résidus) à la loi gaussienne
on commence par vérifier que les hypothèses sur les résidus sont en adéquation avec les données utilisées : 

### Hypothèse 1 : loi gaussienne des erreurs (évaluation de la symétrie) 
```{r}
library(car)
par(mfrow=c(1,2))
nul <- qqPlot(modAnova$residuals,distribution="norm",line="none")
hist(rstandard(modAnova))

```

L'asymétrie observée dans le graphique des résidus (QQ-plot et histogramme) suggère que les résidus ne suivent pas une distribution normale(Gaussienne). Donc, une transformation de variable dépendante (DBH) peut aider à corriger ce problème.

# Transforamtion logarithmique
 Comme les données sont fortement asymétriques vers la droite (positivement asymétrique ), on propose d'appliquer une transformation logarithmique.
 
```{r}
DBH_log = log(data_filtred$DBH)
modAnova_log <- lm(DBH_log~0+releve,data=data_filtred)
```

On vérifier de nouveau l'adéquation des résidus à la loi Gaussienne (vérification de la validté des différents hypothèse normalité(loi Gaussienne),l'indépendance et l'homoscédasticité).

### Hypothèse 1 : loi gaussienne des erreurs (évaluation de la symétrie)

```{r,fig.height=4,fig.width=8}
library(car)
par(mfrow=c(1,2))
nul <- qqPlot(modAnova_log$residuals,distribution="norm",line="none")
hist(rstandard(modAnova_log))
```

* Les points dans le Q-Q plot semblent légèrement déviés dans les queues, avec une courbure vers le haut à droite.

La déviation n'est pas extrêmement forte, mais elle est encore notable.


* L'histogramme montre la distribution des résidus standardisés (ceux qui ont été ajustés pour avoir une moyenne de 0 et une variance de 1).
On peut observer une certaine asymétrie positive, où les résidus semblent être un peu plus concentrés autour de la partie négative et moins nombreux dans les valeurs positives.
L'histogramme n'est pas parfaitement symétrique, mais la déviation n'est pas dramatique non plus. Donc on n'a pas besoin de transformer encore la variable à ce stade.

### Hypothèse 2 : homoscédasticité des erreurs
Afin d'évaluer l'homoscédasticité des erreurs, on peut utiliser un 
diagramme de localisation d'échelle (**scale-location plot** ou **SL-plot**).

```{r,fig.height=5,fig.width=5}
#SL-plot
plot(modAnova_log,which=3,pch=3, add.smooth = FALSE) #Base du SL-plot pré-programmée dans R
abline(h=0.8,col=4,lwd=2) #Ligne horizontale attendue
lo <- loess(sqrt(abs(rstandard(modAnova_log)))~modAnova_log$fitted.values) #Moyenne glissante des points
vFit <- sort(unique(modAnova_log$fitted.values))
predLo <- predict(lo,vFit,se=TRUE)
lines(predLo$fit~vFit,col=2,lwd=2)
#Enveloppe de confiance autour de cette moyenne glissante :
nFit <- length(vFit); ICBonf <- qnorm(1-0.05/2/nFit)
lines(predLo$fit+ICBonf*predLo$se.fit~sort(
    unique(modAnova_log$fitted.values)
  ),col=2,lwd=2,lty="dashed")
lines(predLo$fit-ICBonf*predLo$se.fit~sort(
    unique(modAnova_log$fitted.values)
  ),col=2,lwd=2,lty="dashed")
```

D'après le scale-location plot obtenu ci-dessus, une légère tendance dans les résidus. Les résidus ne sont pas parfaitement distribués autour de la ligne horizontale (ligne bleue) , mais au contraire, on remarque que la dispersion des résidus semble augmenter légèrement pour les valeurs ajustées les plus élevées.
Donc à partir de ces résultas,  on peut suggérer que l'hypothèse d'homoscédasticité ( homogénité des variances) pourrait être violée, surtout si la dispersion des résidus augmente avec les valeurs ajustées
ce qui suggère qu'une transformation concave peut régler le problème. On tente donc une transformation **Box-Cox**.

```{r}
modAnova_pT <-powerTransform(modAnova_log)
powerTransform(modAnova_log)
modAnova_pT$lambda
modAnova_pT$roundlam
summary(modAnova_pT)
modAnova_transform <- lm(DBH^modAnova_pT$lambda ~ 0 + releve, data = data_filtred)
```

On examine pour la deuxième fois l'hypothèse de homoscédasticité des erreurs: 

```{r,fig.height=5,fig.width=5}
#SL-plot
plot(modAnova_transform,which=3,pch=3, add.smooth = FALSE) #Base du SL-plot pré-programmée dans R
abline(h=0.8,col=4,lwd=2) #Ligne horizontale attendue
lo <- loess(sqrt(abs(rstandard(modAnova_transform)))~modAnova_transform$fitted.values) #Moyenne glissante des points
vFit <- sort(unique(modAnova_transform$fitted.values))
predLo <- predict(lo,vFit,se=TRUE)
lines(predLo$fit~vFit,col=2,lwd=2)
#Enveloppe de confiance autour de cette moyenne glissante :
nFit <- length(vFit); ICBonf <- qnorm(1-0.05/2/nFit)
lines(predLo$fit+ICBonf*predLo$se.fit~sort(
    unique(modAnova_transform$fitted.values)
  ),col=2,lwd=2,lty="dashed")
lines(predLo$fit-ICBonf*predLo$se.fit~sort(
    unique(modAnova_transform$fitted.values)
  ),col=2,lwd=2,lty="dashed")
```




