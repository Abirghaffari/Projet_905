---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r}
library(car)
library(lme4) #Une bibliothèque pour ajuster des modèles mixtes
library(MuMIn)
setwd("D:/Master_SIGMA/UE_905_Analyse_Spatiale_Statistique/Regression Lineaire Statistique/Projet")
dataIni <- read.csv("dataProjet_2025.csv")

dataIni_Querc <- dataIni[
  dataIni$recherche_esp_lb_nom_plantae=="Quercus L., 1753",]
nrow(dataIni_Querc)
barplot(dataIni_Querc$DBH,xlab="Echantillons",ylab="DBH (cm)")
```
```{r,fig.height=5,fig.width=5}
plot(lati~long, data=dataIni_Querc,xlab="Longitude WGS84",ylab="Latitude WGS84",pch=3)
coorPla <- sapply(unique(dataIni$releve),function(idPla){
 vIndPla <- which(dataIni$releve==idPla)
 latiPla <- mean(dataIni$lati[vIndPla],na.rm=TRUE)
 longPla <- mean(dataIni$long[vIndPla],na.rm=TRUE)
 return(c(longPla,latiPla))
})
text(coorPla[1,],coorPla[2,],colnames(coorPla),col=4,cex=0.5,font=2)
```

```{r}
vLatRel <- scale(coef(lm(lati~0+releve,data=dataIni_Querc)))
rownames(vLatRel) <- sub("releve","",rownames(vLatRel))
dataIni_Querc$latiRel <- vLatRel[
  match(dataIni_Querc$releve,rownames(vLatRel)),1]
```
Chaque relevé a une latitude standardisée :

```{r}
par(mfrow=c(1,2))
plot(lati~long, data=dataIni,xlab="Longitude WGS84",ylab="Latitude WGS84",pch=3)
text(coorPla[1,],coorPla[2,],colnames(coorPla),col=4,cex=0.5,font=2)
barplot(t(vLatRel)[,order(t(vLatRel),decreasing=TRUE)],las=2,ylab="Latitude standardisée")
```

Les arbres d'un même relevé sont associés à la même valeur de latitude du 
relevé :
```{r}
plot(sort(dataIni_Querc$latiRel),xlab="Arbres",ylab="Latitude standardisée du relevé")
```

Pour voir si l'effet du relevé est induit en partie par la latitude du relevé,
on pourrait penser intègrer la latitude du relevé dans le modèle précédent :

```{r}
modAnovRegQuadLatRel_Querc_BC <- lm(
  I(log10(DBH))~alti+I(alti^2)+releve+latiRel,data=dataIni_Querc)
summary(modAnovRegQuadLatRel_Querc_BC)
```
```{r}
modRegQuadLatRel_Querc_BC <- lm(
  I(log10(DBH))~alti+I(alti^2)+latiRel,data=dataIni_Querc)
summary(modRegQuadLatRel_Querc_BC)
```
On examine l'ajustement de ce modèle :

```{r}
mod <- modRegQuadLatRel_Querc_BC

par(mfrow=c(1,3))
#DISTRIBUTION SYMETRIQUE
qqPlot(mod,distribution="norm",line="none")
#HOMOSCEDASTICITE
plot(mod,which=3,pch=3, add.smooth = FALSE)
#Ligne horizontale attendue
abline(h=0.8,col=4,lwd=2)
#Moyenne glissante
lo <- loess(
  sqrt(abs(rstandard(mod)))~mod$fitted.values) 
vFit <- sort(unique(mod$fitted.values))
predLo <- predict(lo,vFit,se=TRUE)
lines(predLo$fit~vFit,col=2,lwd=2)
#Enveloppe de confiance autour de cette moyenne glissante :
nFit <- length(vFit); ICBonf <- qnorm(1-0.05/2/nFit)
lines(predLo$fit+ICBonf*predLo$se.fit~vFit,col=2,lwd=2,lty="dashed")
lines(predLo$fit-ICBonf*predLo$se.fit~vFit,col=2,lwd=2,lty="dashed")
#INDEPENDANCE
x <- mod$model$latiRel
plot(mod$residuals~x)
abline(h=0,col=4)
#Moyenne glissante
lo <- loess(
 mod$residuals~x) 
vFit <- sort(unique(x))
predLo <- predict(lo,vFit,se=TRUE)
lines(predLo$fit~vFit,col=2,lwd=2)
#Enveloppe de confiance autour de cette moyenne glissante :
nFit <- length(vFit); ICBonf <- qnorm(1-0.05/2/nFit)
lines(predLo$fit+ICBonf*predLo$se.fit~vFit,col=2,lwd=2,lty="dashed")
lines(predLo$fit-ICBonf*predLo$se.fit~vFit,col=2,lwd=2,lty="dashed")
```
```{r}
modMixRel <- lmer(I(log10(DBH))~1+alti+I(alti^2)+latiRel+(1|releve),data=dataIni_Querc)
```
```{r}
dataIni_Querc <- data.frame(dataIni_Querc,
  alti.s=scale(dataIni_Querc$alti),
  alti.s2=scale(dataIni_Querc$alti)^2)
modMixRel <- lmer(I(log10(DBH))~1+alti.s+alti.s2+latiRel+(1|releve),data=dataIni_Querc)
```

## Diagnostic des hypothèses

### Diagnostics sur les erreurs résiduelles : on fait comme avant

```{r}
ranef(modMixRel)
```
```{r,eval=FALSE}
residuals(modMixRel)
```
On peut effectuer les trois diagnostics usuels sur ces résidus :

```{r,fig.height=3,fig.width=9}
par(mfrow=c(1,3))
#DISTRIBUTION SYMETRIQUE
qqPlot(residuals(modMixRel),distribution="norm",line="none")

#HOMOSCEDASTICITE
vAmp <- sqrt(abs(scale(residuals(modMixRel))))
plot(predict(modMixRel),vAmp)
abline(h=0.8,col=4,lwd=2)
#Moyenne glissante
lo <- loess(vAmp~predict(modMixRel)) 
vFit <- sort(unique(predict(modMixRel)))
predLo <- predict(lo,vFit,se=TRUE)
lines(predLo$fit~vFit,col=2,lwd=2)
#Enveloppe de confiance autour de cette moyenne glissante :
nFit <- length(vFit); ICBonf <- qnorm(1-0.05/2/nFit)
lines(predLo$fit+ICBonf*predLo$se.fit~vFit,col=2,lwd=2,lty="dashed")
lines(predLo$fit-ICBonf*predLo$se.fit~vFit,col=2,lwd=2,lty="dashed")

#INDEPENDANCE
plot(residuals(modMixRel)~predict(modMixRel))
abline(h=0,col=4)
#Moyenne glissante
lo <- loess(residuals(modMixRel)~predict(modMixRel)) 
vFit <- sort(unique(predict(modMixRel)))
predLo <- predict(lo,vFit,se=TRUE)
lines(predLo$fit~vFit,col=2,lwd=2)
#Enveloppe de confiance autour de cette moyenne glissante :
nFit <- length(vFit); ICBonf <- qnorm(1-0.05/2/nFit)
lines(predLo$fit+ICBonf*predLo$se.fit~vFit,col=2,lwd=2,lty="dashed")
lines(predLo$fit-ICBonf*predLo$se.fit~vFit,col=2,lwd=2,lty="dashed")
```
### Diagnostic sur les effets aléatoires

```{r,fig.height=3,fig.width=3}
qqPlot(ranef(modMixRel)$releve[,1],distribution="norm",line="none")
```
```{r,fig.height=3,fig.width=3}
#HOMOSCEDASTICITE
vAmp <- sqrt(abs(scale(ranef(modMixRel)$releve[,1])))
vX <- modMixRel@frame$latiRel[
    match(rownames(ranef(modMixRel)$releve),modMixRel@frame$releve)]
plot(vX,vAmp,ylim=c(0,2))
abline(h=0.8,col=4,lwd=2)
#Moyenne glissante
lo <- loess(vAmp~vX) 
vFit <- sort(unique(vX))
predLo <- predict(lo,vFit,se=TRUE)
lines(predLo$fit~vFit,col=2,lwd=2)
#Enveloppe de confiance autour de cette moyenne glissante :
nFit <- length(vFit); ICBonf <- qnorm(1-0.05/2/nFit)
lines(predLo$fit+ICBonf*predLo$se.fit~vFit,col=2,lwd=2,lty="dashed")
lines(predLo$fit-ICBonf*predLo$se.fit~vFit,col=2,lwd=2,lty="dashed")
```
```{r,fig.height=3,fig.width=3}
#INDEPENDANCE
plot(ranef(modMixRel)$releve[,1]~vX,ylim=c(-2,2))
abline(h=0,col=4)
#Moyenne glissante
lo <- loess(ranef(modMixRel)$releve[,1]~vX) 
vFit <- sort(unique(vX))
predLo <- predict(lo,vFit,se=TRUE)
lines(predLo$fit~vFit,col=2,lwd=2)
#Enveloppe de confiance autour de cette moyenne glissante :
nFit <- length(vFit); ICBonf <- qnorm(1-0.05/2/nFit)
lines(predLo$fit+ICBonf*predLo$se.fit~vFit,col=2,lwd=2,lty="dashed")
lines(predLo$fit-ICBonf*predLo$se.fit~vFit,col=2,lwd=2,lty="dashed")
```
## Analyse des sorties

Le résumé de l'ajustement du modèle s'obtient via la fonction usuelle :
```{r}
summary(modMixRel)
```
```{r}
confint(modMixRel)
```
On note que dans le cadre du package *lme4*, 
la fonction fournit des intervalles
de confiances des effets fixes mais également des intervalles de confince 
des écarts-types des effets 
aléatoires ($\tau$, ligne .sig01 ci-dessus) et erreurs associées 
aux observations ($\sigma$, ligne .sigma ci-dessus)

On peut regarder l'effet qu'a eu 
l'introduction de la modélisation de l'effet relevé en fonction de la latitude 
sur l'estimation des autres effets fixes.
Pour ce faire, on compare les estimateurs 
des autres effets fixes (alti.s et alti.s2) 
entre modèle mixte et modèle avec relevé en effet fixe. 
On commence  par réajuster le modèle avec relevé en effet fixe sur exactement
les mêmes données que le modèle mixte, avec les altitudes standardisées :

```{r}
modAnovRegQuad_Querc_BC_dataMix <- lm(`I(log10(DBH))`~0+alti.s+alti.s2+releve,data=modMixRel@frame)
```

```{r}
print("Modèle mixte :")
confint(modMixRel)[c("alti.s","alti.s2"),]
print("Modèle avec relevé en effet fixe :")
confint(modAnovRegQuad_Querc_BC_dataMix)[c("alti.s","alti.s2"),]
```

On constate qu'on a des intervalles de confiance très similaires entre les deux
modèles, ce qui est rassurant : la modélisation de l'effet relevé introduite 
dans le modèle mixte n'a pas perturbée la perception de l'effet altitude sur les
arbres. Notamment on a bien dans les deux cas que l'effet de alti.s est négatif
à un niveau de confiance de 95%, 
tandis que l'intervalle de confiance à 95% de alti.s2 recouvre 0, 
suggérant que cette pente n'est pas significativement différent de 0.


Contrairement aux fonctions vues plus haut pour les modèles linéaires,
le résumé du modèle fournit par *lme4* ne donne pas de p-valeurs 
associées au fait de tester si chaque effet fixe du modèle est différent de 0.
Néanmoins on peut faire ce test à la main. Pour un effet en particulier, 
on peut utiliser un test de modèle emboîté via
la fonction *anova* vue précédemment. 
Par exemple, on pressent
que alti.s2  n'a pas d'effet significatif sur le diamètre des arbres, on le 
teste comme suit :

```{r}
modMixRel_noAlti2 <- lmer(I(log10(DBH))~1+alti.s+latiRel+(1|releve),data=dataIni_Querc)
anova(modMixRel_noAlti2,modMixRel,test="Chisq")
```

On obtient une p-valeur de 0.36, 
ce qui nous conforte dans le caractère non significatif de l'effet de alti.s2. 
On peut plus systématiquement tester tous les effets fixes du modèle mixte 
via la fonction :


```{r}
drop1(modMixRel,test="Chisq")
```
Cette opération recrée en quelque sorte la colonne de p-valeurs 
manquante dans le résumé du modèle. On constate notamment que 
l'effet de la latitude sur le relévé n'est pas significatif : 
un modèle gaussien de l'effet relevé sans covariable 
aurait tout aussi bien convenu.

Pour terminer, on peut souhaiter obtenir une quantification de la capacité 
globale du modèle à expliquer les variations de diamètre entre les arbres.
Dans les modèles classiques, le coefficient de détermination $R^2$ joue ce rôle,
en quantifiant la part de variance expliquée par le modèle, ou autrement dit la
part d'erreur quadratique absobrée par le modèle par rapport à un modèle sans 
covariables ni sous-populations. La notion de coefficient de détermination
dans un modèle mixte est ambigüe. En effet, il faut décider comment on considère
les effets aléatoires $Z_j$ : est-ce qu'on les compte dans l'absorption de 
l'erreur ou non ? Les deux options sont justifiables. D'un côté, on dispose
d'estimateurs a posteriori de ces effets (les $\hat{Z}_j$), ce qui tendrait à 
dire qu'on les a quantifiés et qu'on peut les compter dans la partie explicative
du modèle. D'un autre côté, ces estimations n'émanent pas directement du modèle
(qui n'estime que $\tau^2$) mais sont faites dans un second temps, en utilisant une 
deuxième fois les données. On peut donc discuter le fait d'attribuer 
leur pouvoir explicatif au modèle lui même. On a donc logiquement deux valeurs 
possibles du $R^2$ dans un modèle mixte. Le $R^2$ conditionnel considère que les
effets aléatoires contribuent à l'explication, tandis que le $R^2$ marginal 
considère qu'ils n'y contribuent pas. Logiquement, le $R^2$ marginal est 
toujours plus faible que le $R^2$ conditionnel.

Pour obtenir ces valeurs de $R^2$, on utilise le package *MuMIn* :

```{r}
r.squaredGLMM(modMixRel)
```

On obtient un $R^2$ marginal de 0.05 et un $R^2$ conditionnel de 0.82. 
La différence est forte, suggérant deux choses. Tout d'abord, 
les fluctuations inter-relevé des moyennes de sous-populations sont très fortes,
ce qu'on savait déjà vu le $R^2$ du le modèle avec relevé en effet fixe, 
et vu la forte valeur estimée de la variance de l'effet aléatoire relevé dans le modèle mixte.
Ensuite, la latitude du relevé contribue peu à absorber cette effet
car la latitude du relevé contribue au $R^2$ marginal, qui est faible. 
Ici encore, on pouvait s'y attendre vu le caractère non significatif
de la latitude du relevé obtenue lors des tests systématique par le *drop1*.
